import "process.hob" as process;
import "result.hob" as result;

use result.Result;

extern(clone) fun internal(fn: fun (*void) -> i32, stack: *void, flags: i32, arg: *void) -> i32;

type Flags = i32;

public fun flags() -> Flags { return 0 as Flags; }
public fun Flags.newCGroup(self) -> Flags { return (self as i32 | 0x2000000) as Flags; }
public fun Flags.newIpc(self) -> Flags { return (self as i32 | 0x8000000) as Flags; }
public fun Flags.newNet(self) -> Flags { return (self as i32 | 0x40000000) as Flags; }
public fun Flags.newPid(self) -> Flags { return (self as i32 | 0x20000000) as Flags; }
public fun Flags.newUser(self) -> Flags { return (self as i32 | 0x10000000) as Flags; }
public fun Flags.newNs(self) -> Flags { return (self as i32 | 0x20000) as Flags; }
public fun Flags.newUts(self) -> Flags { return (self as i32 | 0x4000000) as Flags; }
public fun Flags.vm(self) -> Flags { return (self as i32 | (1 << 8)) as Flags; }
public fun Flags.vFork(self) -> Flags { return (self as i32 | (1 << 14)) as Flags; }
public fun Flags.sigChld(self) -> Flags { return (self as i32 | 17) as Flags; }

public fun clone<Arg>(fn: fun (*Arg) -> i32, stack: *void, flags: Flags, arg: *Arg) -> Result.<process.Pid> {
    return result.newMapped.<process.Pid>(
        internal(fn as fun (*void) -> i32, stack, flags, arg as *void),
        fun (value: i32) -> process.Pid {
            return value as process.Pid;
        });
}
